#include "rtdef.h"

/* __lowest_bit_bitmap[]数组解析
 * 将一个8位整形数的取值范围0-255作为数组的索引,
 * 索引值第一个出现1(从最低位开始)的位号作为该数组索引下的成员值
 * 举例：十进制数10的二进制为0000 1010,从最低位开始
 * 第一个出现1的位号为bit1,则有__lowest_bit_bitmap[10]=1
 * 注意：只需要找到第一个出现1的位号即可
 * 只要是奇数,说明bit1=1那么最高优先级就0优先级
 */
const rt_uint8_t __lowest_bit_bitmap[] = 
{
	/*位号*/
	/*00*/ 0,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
	/*10*/ 4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
	/*20*/ 5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
	/*30*/ 4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
	/*40*/ 6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
	/*50*/ 4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
	/*60*/ 5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
	/*70*/ 4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
	/*80*/ 7,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
	/*90*/ 4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
	/*A0*/ 5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
	/*B0*/ 4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
	/*C0*/ 6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
	/*D0*/ 4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
	/*E0*/ 5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
	/*F0*/ 4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0
};



/* rt_strncpy
 * 字符拷贝函数
 * dst:		要拷贝到的地址
 * src:		源字符
 * n:			要拷贝的字节数
 * return:目的地址
 */
char *rt_strncpy(char *dst,const char *src,rt_ubase_t n)
{
	if(n!=0)
	{
		char *d = dst;
		const char *s = src;
		do{
			if((*d++ = *s++) == 0)/*拷贝失败*/
			{
				while(--n != 0)/*后面填充为0*/
					*d++ = 0;
				break;
			}
		}while(--n != 0);
	}
	return (dst);
}
	

int __rt_ffs(int value)
{
	if(0 == value)
		return 0;
	
	if(value & 0xff)
		return __lowest_bit_bitmap[value & 0xff] + 1;
	
	if(value & 0xff00)
		return __lowest_bit_bitmap[(value & 0xff00)>>8] + 9;
	
	if(value & 0xff0000)
		return __lowest_bit_bitmap[(value & 0xff0000)>>16] + 17;
	
	return __lowest_bit_bitmap[(value & 0xff000000)>>24] + 25;
	
}
	

